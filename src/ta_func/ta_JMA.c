/* TA-LIB Copyright (c) 1999-2025, Mario Fortier
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 * - Redistributions of source code must retain the above copyright
 *   notice, this list of conditions and the following disclaimer.
 *
 * - Redistributions in binary form must reproduce the above copyright
 *   notice, this list of conditions and the following disclaimer in
 *   the documentation and/or other materials provided with the
 *   distribution.
 *
 * - Neither name of author nor the names of its contributors
 *   may be used to endorse or promote products derived from this
 *   software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
 * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/* List of contributors:
 *
 *  Initial  Name/description
 *  -------------------------------------------------------------------
 *  AI       AI Assistant
 *
 * Change history:
 *
 *  MMDDYY BY     Description
 *  -------------------------------------------------------------------
 *  010125 AI     Initial Version - Jurik Moving Average implementation
 */

/**** START GENCODE SECTION 1 - DO NOT DELETE THIS LINE ****/
/* All code within this section is automatically
 * generated by gen_code. Any modification will be lost
 * next time gen_code is run.
 */
/* Generated */ 
/* Generated */ #if defined( _MANAGED )
/* Generated */    #include "TA-Lib-Core.h"
/* Generated */    #define TA_INTERNAL_ERROR(Id) (RetCode::InternalError)
/* Generated */    namespace TicTacTec { namespace TA { namespace Library {
/* Generated */ #elif defined( _JAVA )
/* Generated */    #include "ta_defs.h"
/* Generated */    #include "ta_java_defs.h"
/* Generated */    #define TA_INTERNAL_ERROR(Id) (RetCode.InternalError)
/* Generated */ #elif defined( _RUST )
/* Generated */    #include "ta_defs.h"
/* Generated */    #define TA_INTERNAL_ERROR(Id) (RetCode.InternalError)
/* Generated */    impl Core {
/* Generated */ #else
/* Generated */    #include <string.h>
/* Generated */    #include <math.h>
/* Generated */    #include "ta_func.h"
/* Generated */ #endif
/* Generated */ 
/* Generated */ #ifndef TA_UTILITY_H
/* Generated */    #include "ta_utility.h"
/* Generated */ #endif
/* Generated */ 
/* Generated */ #ifndef TA_MEMORY_H
/* Generated */    #include "ta_memory.h"
/* Generated */ #endif
/* Generated */ 
/* Generated */ #define TA_PREFIX(x) TA_##x
/* Generated */ #define INPUT_TYPE   double
/* Generated */ 
/* Generated */ #if defined( _MANAGED )
/* Generated */ int Core::JmaLookback( int           optInTimePeriod,
/* Generated */                        int           optInPhase,
/* Generated */                        int           optInVolPeriods )  /* From 1 to 100000 */
/* Generated */ 
/* Generated */ #elif defined( _JAVA )
/* Generated */ public int jmaLookback( int           optInTimePeriod,
/* Generated */                         int           optInPhase,
/* Generated */                         int           optInVolPeriods )  /* From 1 to 100000 */
/* Generated */ 
/* Generated */ #elif defined( _RUST )
/* Generated */ pub fn jma_lookback(
/* Generated */ optInTimePeriod: i32,
/* Generated */ optInPhase: i32,
/* Generated */ optInVolPeriods: i32) -> i32
/* Generated */ #else
/* Generated */ TA_LIB_API int TA_JMA_Lookback( int           optInTimePeriod,
/* Generated */                                  int           optInPhase,
/* Generated */                                  int           optInVolPeriods )  /* From 1 to 100000 */
/* Generated */ 
/* Generated */ #endif
/**** END GENCODE SECTION 1 - DO NOT DELETE THIS LINE ****/
{
   /* insert local variable here */

/**** START GENCODE SECTION 2 - DO NOT DELETE THIS LINE ****/
/* Generated */ #ifndef TA_FUNC_NO_RANGE_CHECK
/* Generated */    /* min/max are checked for optInTimePeriod. */
/* Generated */    if( (int)optInTimePeriod == TA_INTEGER_DEFAULT ) {
/* Generated */ 	  optInTimePeriod = 14;
/* Generated */    } else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) ) {
/* Generated */ 	  return -1;
/* Generated */ }
/* Generated */    /* min/max are checked for optInPhase. */
/* Generated */    if( (int)optInPhase == TA_INTEGER_DEFAULT ) {
/* Generated */ 	  optInPhase = 0;
/* Generated */    } else if( ((int)optInPhase < -100) || ((int)optInPhase > 100) ) {
/* Generated */ 	  return -1;
/* Generated */ }
/* Generated */    /* min/max are checked for optInVolPeriods. */
/* Generated */    if( (int)optInVolPeriods == TA_INTEGER_DEFAULT ) {
/* Generated */ 	  optInVolPeriods = 65;
/* Generated */    } else if( ((int)optInVolPeriods < 1) || ((int)optInVolPeriods > 100000) ) {
/* Generated */ 	  return -1;
/* Generated */ }
/* Generated */ #endif /* TA_FUNC_NO_RANGE_CHECK */
/**** END GENCODE SECTION 2 - DO NOT DELETE THIS LINE ****/

   /* insert lookback code here. */
   /* JMA requires at least vol_periods bars before first valid output */
   return optInVolPeriods;
}

/**** START GENCODE SECTION 3 - DO NOT DELETE THIS LINE ****/
/*
 * TA_JMA - Jurik Moving Average
 * 
 * Input  = double
 * Output = double, double, double
 * 
 * Optional Parameters
 * -------------------
 * optInTimePeriod:(From 1 to 100000)
 *    Period length for the moving average
 * 
 * optInPhase:(From -100 to 100)
 *    Phase parameter (typically 0-100). Controls the phase ratio.
 * 
 * optInVolPeriods:(From 1 to 100000)
 *    Period for average volatility calculation
 * 
 * 
 */
/* Generated */ 
/* Generated */ #if defined( _MANAGED ) && defined( USE_SUBARRAY )
/* Generated */ enum class Core::RetCode Core::Jma( int    startIdx,
/* Generated */                                    int    endIdx,
/* Generated */                                    SubArray<double>^ inReal,
/* Generated */                                    int           optInTimePeriod, /* From 1 to 100000 */
/* Generated */                                    int           optInPhase, /* From -100 to 100 */
/* Generated */                                    int           optInVolPeriods, /* From 1 to 100000 */
/* Generated */                                    [Out]int%    outBegIdx,
/* Generated */                                    [Out]int%    outNBElement,
/* Generated */                                    SubArray<double>^  outRealJMA,
/* Generated */                                    SubArray<double>^  outRealUpperBand,
/* Generated */                                    SubArray<double>^  outRealLowerBand )
/* Generated */ #elif defined( _MANAGED )
/* Generated */ enum class Core::RetCode Core::Jma( int    startIdx,
/* Generated */                                    int    endIdx,
/* Generated */                                    cli::array<double>^ inReal,
/* Generated */                                    int           optInTimePeriod, /* From 1 to 100000 */
/* Generated */                                    int           optInPhase, /* From -100 to 100 */
/* Generated */                                    int           optInVolPeriods, /* From 1 to 100000 */
/* Generated */                                    [Out]int%    outBegIdx,
/* Generated */                                    [Out]int%    outNBElement,
/* Generated */                                    cli::array<double>^  outRealJMA,
/* Generated */                                    cli::array<double>^  outRealUpperBand,
/* Generated */                                    cli::array<double>^  outRealLowerBand )
/* Generated */ #elif defined( _JAVA )
/* Generated */ public RetCode jma( int    startIdx,
/* Generated */                     int    endIdx,
/* Generated */                     double       inReal[],
/* Generated */                     int           optInTimePeriod, /* From 1 to 100000 */
/* Generated */                     int           optInPhase, /* From -100 to 100 */
/* Generated */                     int           optInVolPeriods, /* From 1 to 100000 */
/* Generated */                     MInteger     outBegIdx,
/* Generated */                     MInteger     outNBElement,
/* Generated */                     double        outRealJMA[],
/* Generated */                     double        outRealUpperBand[],
/* Generated */                     double        outRealLowerBand[] )
/* Generated */ #elif defined( _RUST )
/* Generated */ pub fn jma(startIdx: usize,
/* Generated */            endIdx: usize,
/* Generated */            inReal: &[f64],
/* Generated */            optInTimePeriod: i32,
/* Generated */            optInPhase: i32,
/* Generated */            optInVolPeriods: i32,
/* Generated */            outBegIdx: &mut usize,
/* Generated */            outNBElement: &mut usize,
/* Generated */            outRealJMA: &mut [f64],
/* Generated */            outRealUpperBand: &mut [f64],
/* Generated */            outRealLowerBand: &mut [f64]) -> RetCode
/* Generated */ #else
/* Generated */ TA_LIB_API TA_RetCode TA_JMA( int    startIdx,
/* Generated */                               int    endIdx,
/* Generated */                                          const double inReal[],
/* Generated */                                          int           optInTimePeriod, /* From 1 to 100000 */
/* Generated */                                          int           optInPhase, /* From -100 to 100 */
/* Generated */                                          int           optInVolPeriods, /* From 1 to 100000 */
/* Generated */                                          int          *outBegIdx,
/* Generated */                                          int          *outNBElement,
/* Generated */                                          double        outRealJMA[],
/* Generated */                                          double        outRealUpperBand[],
/* Generated */                                          double        outRealLowerBand[] )
/* Generated */ #endif
/**** END GENCODE SECTION 3 - DO NOT DELETE THIS LINE ****/
{
   /* insert local variable here */
   int i, today, outIdx, lookbackTotal;
   double beta, pFactor, pRelVol, PR;
   double MA1, Det0, MA2, Det1;
   double upper_band, lower_band;
   double Kv, dPow, dPow_prev, alpha;
   double del1, del2, abs_del1, abs_del2;
   double volty, r_volty, max_r_volty;
   double avg_volty_sum;
   int v_sum_window_start;
   ARRAY_REF( volty_array );
   ARRAY_REF( v_sum_array );
   ARRAY_REF( avg_volty_array );

/**** START GENCODE SECTION 4 - DO NOT DELETE THIS LINE ****/
/* Generated */ 
/* Generated */ #ifndef TA_FUNC_NO_RANGE_CHECK
/* Generated */ 
/* Generated */    /* Validate the requested output range. */
/* Generated */ #if defined( _RUST )
/* Generated */    /* Skip negative checks for Rust since startIdx/endIdx are usize (unsigned) */
/* Generated */    if( endIdx < startIdx ) {
/* Generated */       return ENUM_VALUE(RetCode,TA_OUT_OF_RANGE_END_INDEX,OutOfRangeEndIndex);
/* Generated */    }
/* Generated */ #else
/* Generated */    if( startIdx < 0 ) {
/* Generated */       return ENUM_VALUE(RetCode,TA_OUT_OF_RANGE_START_INDEX,OutOfRangeStartIndex);
/* Generated */    }
/* Generated */    if( (endIdx < 0) || (endIdx < startIdx)) {
/* Generated */       return ENUM_VALUE(RetCode,TA_OUT_OF_RANGE_END_INDEX,OutOfRangeEndIndex);
/* Generated */    }
/* Generated */ #endif
/* Generated */ 
/* Generated */ #if defined( _RUST )
/* Generated */ 
/* Generated */ #else
/* Generated */    #if !defined(_JAVA)
/* Generated */    if( !inReal ) { return ENUM_VALUE(RetCode,TA_BAD_PARAM,BadParam); }
/* Generated */    #endif /* !defined(_JAVA)*/
/* Generated */    /* min/max are checked for optInTimePeriod. */
/* Generated */    if( (int)optInTimePeriod == TA_INTEGER_DEFAULT ) {
/* Generated */ 	  optInTimePeriod = 14;
/* Generated */    } else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) ) {
/* Generated */ 	  return ENUM_VALUE(RetCode,TA_BAD_PARAM,BadParam);
/* Generated */ }
/* Generated */    /* min/max are checked for optInPhase. */
/* Generated */    if( (int)optInPhase == TA_INTEGER_DEFAULT ) {
/* Generated */ 	  optInPhase = 0;
/* Generated */    } else if( ((int)optInPhase < -100) || ((int)optInPhase > 100) ) {
/* Generated */ 	  return ENUM_VALUE(RetCode,TA_BAD_PARAM,BadParam);
/* Generated */ }
/* Generated */    /* min/max are checked for optInVolPeriods. */
/* Generated */    if( (int)optInVolPeriods == TA_INTEGER_DEFAULT ) {
/* Generated */ 	  optInVolPeriods = 65;
/* Generated */    } else if( ((int)optInVolPeriods < 1) || ((int)optInVolPeriods > 100000) ) {
/* Generated */ 	  return ENUM_VALUE(RetCode,TA_BAD_PARAM,BadParam);
/* Generated */ }
/* Generated */    #if !defined(_JAVA)
/* Generated */    if( !outRealJMA )
/* Generated */       return ENUM_VALUE(RetCode,TA_BAD_PARAM,BadParam);
/* Generated */ 
/* Generated */    if( !outRealUpperBand )
/* Generated */       return ENUM_VALUE(RetCode,TA_BAD_PARAM,BadParam);
/* Generated */ 
/* Generated */    if( !outRealLowerBand )
/* Generated */       return ENUM_VALUE(RetCode,TA_BAD_PARAM,BadParam);
/* Generated */ 
/* Generated */    #endif /* !defined(_JAVA) */
/* Generated */ #endif
/* Generated */ #endif /* TA_FUNC_NO_RANGE_CHECK */
/* Generated */ 
/**** END GENCODE SECTION 4 - DO NOT DELETE THIS LINE ****/

   /* Insert TA function code here. */

   /* Default return values */
   VALUE_HANDLE_DEREF_TO_ZERO(outBegIdx);
   VALUE_HANDLE_DEREF_TO_ZERO(outNBElement);

   /* Identify the minimum number of price bar needed
    * to calculate at least one output.
    */
   lookbackTotal = optInVolPeriods;

   /* Move up the start index if there is not
    * enough initial data.
    */
   if( startIdx < lookbackTotal )
      startIdx = lookbackTotal;

   /* Make sure there is still something to evaluate. */
   if( startIdx > endIdx )
   {
      VALUE_HANDLE_DEREF_TO_ZERO(outBegIdx);
      VALUE_HANDLE_DEREF_TO_ZERO(outNBElement);
      return ENUM_VALUE(RetCode,TA_SUCCESS,Success);
   }

   /* Allocate arrays for volatility calculations */
   ARRAY_ALLOC(volty_array, endIdx - startIdx + lookbackTotal + 1);
   #if !defined(_JAVA)
      if( !volty_array )
      {
         VALUE_HANDLE_DEREF_TO_ZERO(outBegIdx);
         VALUE_HANDLE_DEREF_TO_ZERO(outNBElement);
         return ENUM_VALUE(RetCode,TA_ALLOC_ERR,AllocErr);
      }
   #endif

   ARRAY_ALLOC(v_sum_array, endIdx - startIdx + lookbackTotal + 1);
   #if !defined(_JAVA)
      if( !v_sum_array )
      {
         ARRAY_FREE(volty_array);
         VALUE_HANDLE_DEREF_TO_ZERO(outBegIdx);
         VALUE_HANDLE_DEREF_TO_ZERO(outNBElement);
         return ENUM_VALUE(RetCode,TA_ALLOC_ERR,AllocErr);
      }
   #endif

   ARRAY_ALLOC(avg_volty_array, endIdx - startIdx + lookbackTotal + 1);
   #if !defined(_JAVA)
      if( !avg_volty_array )
      {
         ARRAY_FREE(volty_array);
         ARRAY_FREE(v_sum_array);
         VALUE_HANDLE_DEREF_TO_ZERO(outBegIdx);
         VALUE_HANDLE_DEREF_TO_ZERO(outNBElement);
         return ENUM_VALUE(RetCode,TA_ALLOC_ERR,AllocErr);
      }
   #endif

   /* Calculate periodic ratio (beta) */
   beta = 0.45 * (optInTimePeriod - 1.0) / (0.45 * (optInTimePeriod - 1.0) + 2.0);

   /* Calculate periodic factor */
   pFactor = std_log(std_sqrt((double)optInTimePeriod)) / std_log(2.0) + 2.0;
   if( pFactor < 0.0 )
      pFactor = 0.0;

   /* Calculate pRelVol (power of relative volatility) */
   pRelVol = pFactor - 2.0;
   if( pRelVol < 0.5 )
      pRelVol = 0.5;

   /* Calculate Phase Ratio (PR) */
   if( optInPhase > 100 )
      PR = 2.5;
   else
      PR = optInPhase / 100.0 + 1.5;

   /* Initialize state variables */
   MA1 = inReal[startIdx - lookbackTotal];  /* Stage 1: Adaptive EMA */
   Det0 = 0.0;                              /* Stage 2: Kalman filter detector */
   MA2 = inReal[startIdx - lookbackTotal];  /* Stage 2: Kalman filtered value */
   Det1 = 0.0;                              /* Stage 3: Final smoothing detector */

   /* Initialize Jurik Bands */
   upper_band = inReal[startIdx - lookbackTotal];
   lower_band = inReal[startIdx - lookbackTotal];

   /* Initialize dPow_prev for dynamic Kv calculation */
   /* Use pRelVol as initial value (equivalent to rVolty=1) */
   dPow_prev = pRelVol;

   /* Initialize running sum for avg_volty optimization */
   avg_volty_sum = 0.0;
   v_sum_window_start = 0;

   /* Track current JMA value (separate from output) */
   double current_jma = inReal[startIdx - lookbackTotal];

   /* Process each bar */
   today = startIdx - lookbackTotal;
   outIdx = 0;

   while( today <= endIdx )
   {
      /* Calculate Kv (volatility factor) using previous bar's dPow value */
      Kv = pow(beta, std_sqrt(dPow_prev));

      /* Calculate Jurik Bands */
      del1 = inReal[today] - upper_band;
      del2 = inReal[today] - lower_band;

      if( del1 > 0.0 )
         upper_band = inReal[today];
      else
         upper_band = inReal[today] - Kv * del1;

      if( del2 < 0.0 )
         lower_band = inReal[today];
      else
         lower_band = inReal[today] - Kv * del2;

      /* Calculate volatility (Volty) */
      abs_del1 = std_fabs(del1);
      abs_del2 = std_fabs(del2);

      if( abs_del1 == abs_del2 )
         volty = 0.0;
      else
         volty = (abs_del1 > abs_del2) ? abs_del1 : abs_del2;

      /* Calculate vSum (incremental sum) */
      if( today >= startIdx - lookbackTotal + 10 )
      {
         v_sum_array[today - (startIdx - lookbackTotal)] = 
            v_sum_array[today - (startIdx - lookbackTotal) - 1] + 
            (volty - volty_array[today - (startIdx - lookbackTotal) - 10]) / 10.0;
      }
      else if( today > startIdx - lookbackTotal )
      {
         v_sum_array[today - (startIdx - lookbackTotal)] = 
            v_sum_array[today - (startIdx - lookbackTotal) - 1];
      }
      else
      {
         v_sum_array[0] = volty;
      }

      volty_array[today - (startIdx - lookbackTotal)] = volty;

      /* Calculate average volatility (AvgVolty) using optimized running sum */
      if( today >= startIdx - lookbackTotal + optInVolPeriods - 1 )
      {
         int array_idx = today - (startIdx - lookbackTotal);
         if( today == startIdx - lookbackTotal + optInVolPeriods - 1 )
         {
            /* Initialize running sum on first full window */
            avg_volty_sum = 0.0;
            for( i = array_idx - optInVolPeriods + 1; i <= array_idx; i++ )
               avg_volty_sum += v_sum_array[i];
            v_sum_window_start = array_idx - optInVolPeriods + 1;
         }
         else
         {
            /* Update running sum: remove oldest, add newest */
            avg_volty_sum = avg_volty_sum - v_sum_array[v_sum_window_start] + v_sum_array[array_idx];
            v_sum_window_start++;
         }
         avg_volty_array[array_idx] = avg_volty_sum / optInVolPeriods;
      }
      else if( today > startIdx - lookbackTotal )
      {
         /* Use available data for partial average */
         int array_idx = today - (startIdx - lookbackTotal);
         double sum = 0.0;
         for( i = 0; i <= array_idx; i++ )
            sum += v_sum_array[i];
         avg_volty_array[array_idx] = sum / (array_idx + 1);
      }
      else
      {
         avg_volty_array[0] = (v_sum_array[0] > 0.0) ? v_sum_array[0] : 1.0;
      }

      /* Calculate relative volatility (rVolty) */
      {
         int array_idx = today - (startIdx - lookbackTotal);
         if( avg_volty_array[array_idx] > 0.0 )
            r_volty = volty / avg_volty_array[array_idx];
         else
            r_volty = 1.0;

         /* Apply bounds to rVolty */
         if( r_volty < 1.0 )
            r_volty = 1.0;

         /* Calculate upper bound for rVolty */
         if( pRelVol > 0.0 )
         {
            max_r_volty = pow(pFactor, 1.0 / pRelVol);
            if( r_volty > max_r_volty )
               r_volty = max_r_volty;
         }
      }

      /* Calculate dPow and alpha (dynamic factor) */
      dPow = pow(r_volty, pRelVol);
      alpha = pow(beta, dPow);

      /* Stage 1: Preliminary smoothing by adaptive EMA */
      MA1 = (1.0 - alpha) * inReal[today] + alpha * MA1;

      /* Stage 2: One more preliminary smoothing by Kalman filter */
      Det0 = (inReal[today] - MA1) * (1.0 - beta) + beta * Det0;
      MA2 = MA1 + PR * Det0;

      /* Stage 3: Final smoothing by unique Jurik adaptive filter */
      if( today > startIdx - lookbackTotal )
      {
         double one_minus_alpha_sq = (1.0 - alpha) * (1.0 - alpha);
         double alpha_sq = alpha * alpha;
         Det1 = (MA2 - current_jma) * one_minus_alpha_sq + alpha_sq * Det1;
         current_jma = current_jma + Det1;
      }
      else
      {
         current_jma = MA2;
      }

      /* Store dPow for use in next iteration's Kv calculation */
      dPow_prev = dPow;

      /* Store outputs (only output valid values starting from startIdx) */
      if( today >= startIdx )
      {
         outRealJMA[outIdx] = current_jma;
         outRealUpperBand[outIdx] = upper_band;
         outRealLowerBand[outIdx] = lower_band;
         outIdx++;
      }

      today++;
   }

   ARRAY_FREE(volty_array);
   ARRAY_FREE(v_sum_array);
   ARRAY_FREE(avg_volty_array);

   VALUE_HANDLE_DEREF(outBegIdx) = startIdx;
   VALUE_HANDLE_DEREF(outNBElement) = outIdx;

   return ENUM_VALUE(RetCode,TA_SUCCESS,Success);
}

/**** START GENCODE SECTION 5 - DO NOT DELETE THIS LINE ****/
/* Generated */ 
/* Generated */ #define  USE_SINGLE_PRECISION_INPUT
/* Generated */ #if !defined( _MANAGED ) && !defined( _JAVA )
/* Generated */    #undef   TA_PREFIX
/* Generated */    #define  TA_PREFIX(x) TA_S_##x
/* Generated */ #endif
/* Generated */ #undef   INPUT_TYPE
/* Generated */ #define  INPUT_TYPE float
/* Generated */ #if defined( _MANAGED ) && defined( USE_SUBARRAY )
/* Generated */ enum class Core::RetCode Core::Jma( int    startIdx,
/* Generated */                                    int    endIdx,
/* Generated */                                    SubArray<float>^ inReal,
/* Generated */                                    int           optInTimePeriod, /* From 1 to 100000 */
/* Generated */                                    int           optInPhase, /* From -100 to 100 */
/* Generated */                                    int           optInVolPeriods, /* From 1 to 100000 */
/* Generated */                                    [Out]int%    outBegIdx,
/* Generated */                                    [Out]int%    outNBElement,
/* Generated */                                    SubArray<double>^  outRealJMA,
/* Generated */                                    SubArray<double>^  outRealUpperBand,
/* Generated */                                    SubArray<double>^  outRealLowerBand )
/* Generated */ #elif defined( _MANAGED )
/* Generated */ enum class Core::RetCode Core::Jma( int    startIdx,
/* Generated */                                    int    endIdx,
/* Generated */                                    cli::array<float>^ inReal,
/* Generated */                                    int           optInTimePeriod, /* From 1 to 100000 */
/* Generated */                                    int           optInPhase, /* From -100 to 100 */
/* Generated */                                    int           optInVolPeriods, /* From 1 to 100000 */
/* Generated */                                    [Out]int%    outBegIdx,
/* Generated */                                    [Out]int%    outNBElement,
/* Generated */                                    cli::array<double>^  outRealJMA,
/* Generated */                                    cli::array<double>^  outRealUpperBand,
/* Generated */                                    cli::array<double>^  outRealLowerBand )
/* Generated */ #elif defined( _JAVA )
/* Generated */ public RetCode jma( int    startIdx,
/* Generated */                     int    endIdx,
/* Generated */                     float        inReal[],
/* Generated */                     int           optInTimePeriod, /* From 1 to 100000 */
/* Generated */                     int           optInPhase, /* From -100 to 100 */
/* Generated */                     int           optInVolPeriods, /* From 1 to 100000 */
/* Generated */                     MInteger     outBegIdx,
/* Generated */                     MInteger     outNBElement,
/* Generated */                     double        outRealJMA[],
/* Generated */                     double        outRealUpperBand[],
/* Generated */                     double        outRealLowerBand[] )
/* Generated */ #elif defined( _RUST )
/* Generated */ pub fn jma_s(startIdx: usize,
/* Generated */              endIdx: usize,
/* Generated */              inReal: &[f32],
/* Generated */              optInTimePeriod: i32,
/* Generated */              optInPhase: i32,
/* Generated */              optInVolPeriods: i32,
/* Generated */              outBegIdx: &mut usize,
/* Generated */              outNBElement: &mut usize,
/* Generated */              outRealJMA: &mut [f64],
/* Generated */              outRealUpperBand: &mut [f64],
/* Generated */              outRealLowerBand: &mut [f64]) -> RetCode
/* Generated */ #else
/* Generated */ TA_RetCode TA_S_JMA( int    startIdx,
/* Generated */                      int    endIdx,
/* Generated */                      const float  inReal[],
/* Generated */                      int           optInTimePeriod, /* From 1 to 100000 */
/* Generated */                      int           optInPhase, /* From -100 to 100 */
/* Generated */                      int           optInVolPeriods, /* From 1 to 100000 */
/* Generated */                      int          *outBegIdx,
/* Generated */                      int          *outNBElement,
/* Generated */                      double        outRealJMA[],
/* Generated */                      double        outRealUpperBand[],
/* Generated */                      double        outRealLowerBand[] )
/* Generated */ #endif
/* Generated */ {
/* Generated */    int i, today, outIdx, lookbackTotal;
/* Generated */    double beta, pFactor, pRelVol, PR;
/* Generated */    double MA1, Det0, MA2, Det1;
/* Generated */    double upper_band, lower_band;
/* Generated */    double Kv, dPow, dPow_prev, alpha;
/* Generated */    double del1, del2, abs_del1, abs_del2;
/* Generated */    double volty, r_volty, max_r_volty;
/* Generated */    double avg_volty_sum;
/* Generated */    int v_sum_window_start;
/* Generated */    ARRAY_REF( volty_array );
/* Generated */    ARRAY_REF( v_sum_array );
/* Generated */    ARRAY_REF( avg_volty_array );
/* Generated */  #ifndef TA_FUNC_NO_RANGE_CHECK
/* Generated */  #if defined( _RUST )
/* Generated */     if( endIdx < startIdx ) {
/* Generated */        return ENUM_VALUE(RetCode,TA_OUT_OF_RANGE_END_INDEX,OutOfRangeEndIndex);
/* Generated */     }
/* Generated */  #else
/* Generated */     if( startIdx < 0 ) {
/* Generated */        return ENUM_VALUE(RetCode,TA_OUT_OF_RANGE_START_INDEX,OutOfRangeStartIndex);
/* Generated */     }
/* Generated */     if( (endIdx < 0) || (endIdx < startIdx)) {
/* Generated */        return ENUM_VALUE(RetCode,TA_OUT_OF_RANGE_END_INDEX,OutOfRangeEndIndex);
/* Generated */     }
/* Generated */  #endif
/* Generated */  #if defined( _RUST )
/* Generated */  #else
/* Generated */     #if !defined(_JAVA)
/* Generated */     if( !inReal ) { return ENUM_VALUE(RetCode,TA_BAD_PARAM,BadParam); }
/* Generated */     #endif 
/* Generated */     if( (int)optInTimePeriod == TA_INTEGER_DEFAULT ) {
/* Generated */  	  optInTimePeriod = 14;
/* Generated */     } else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) ) {
/* Generated */  	  return ENUM_VALUE(RetCode,TA_BAD_PARAM,BadParam);
/* Generated */  }
/* Generated */     if( (int)optInPhase == TA_INTEGER_DEFAULT ) {
/* Generated */  	  optInPhase = 0;
/* Generated */     } else if( ((int)optInPhase < -100) || ((int)optInPhase > 100) ) {
/* Generated */  	  return ENUM_VALUE(RetCode,TA_BAD_PARAM,BadParam);
/* Generated */  }
/* Generated */     if( (int)optInVolPeriods == TA_INTEGER_DEFAULT ) {
/* Generated */  	  optInVolPeriods = 65;
/* Generated */     } else if( ((int)optInVolPeriods < 1) || ((int)optInVolPeriods > 100000) ) {
/* Generated */  	  return ENUM_VALUE(RetCode,TA_BAD_PARAM,BadParam);
/* Generated */  }
/* Generated */     #if !defined(_JAVA)
/* Generated */     if( !outRealJMA )
/* Generated */        return ENUM_VALUE(RetCode,TA_BAD_PARAM,BadParam);
/* Generated */     if( !outRealUpperBand )
/* Generated */        return ENUM_VALUE(RetCode,TA_BAD_PARAM,BadParam);
/* Generated */     if( !outRealLowerBand )
/* Generated */        return ENUM_VALUE(RetCode,TA_BAD_PARAM,BadParam);
/* Generated */     #endif 
/* Generated */  #endif
/* Generated */  #endif 
/* Generated */    VALUE_HANDLE_DEREF_TO_ZERO(outBegIdx);
/* Generated */    VALUE_HANDLE_DEREF_TO_ZERO(outNBElement);
/* Generated */    lookbackTotal = optInVolPeriods;
/* Generated */    if( startIdx < lookbackTotal )
/* Generated */       startIdx = lookbackTotal;
/* Generated */    if( startIdx > endIdx )
/* Generated */    {
/* Generated */       VALUE_HANDLE_DEREF_TO_ZERO(outBegIdx);
/* Generated */       VALUE_HANDLE_DEREF_TO_ZERO(outNBElement);
/* Generated */       return ENUM_VALUE(RetCode,TA_SUCCESS,Success);
/* Generated */    }
/* Generated */    ARRAY_ALLOC(volty_array, endIdx - startIdx + lookbackTotal + 1);
/* Generated */    #if !defined(_JAVA)
/* Generated */       if( !volty_array )
/* Generated */       {
/* Generated */          VALUE_HANDLE_DEREF_TO_ZERO(outBegIdx);
/* Generated */          VALUE_HANDLE_DEREF_TO_ZERO(outNBElement);
/* Generated */          return ENUM_VALUE(RetCode,TA_ALLOC_ERR,AllocErr);
/* Generated */       }
/* Generated */    #endif
/* Generated */    ARRAY_ALLOC(v_sum_array, endIdx - startIdx + lookbackTotal + 1);
/* Generated */    #if !defined(_JAVA)
/* Generated */       if( !v_sum_array )
/* Generated */       {
/* Generated */          ARRAY_FREE(volty_array);
/* Generated */          VALUE_HANDLE_DEREF_TO_ZERO(outBegIdx);
/* Generated */          VALUE_HANDLE_DEREF_TO_ZERO(outNBElement);
/* Generated */          return ENUM_VALUE(RetCode,TA_ALLOC_ERR,AllocErr);
/* Generated */       }
/* Generated */    #endif
/* Generated */    ARRAY_ALLOC(avg_volty_array, endIdx - startIdx + lookbackTotal + 1);
/* Generated */    #if !defined(_JAVA)
/* Generated */       if( !avg_volty_array )
/* Generated */       {
/* Generated */          ARRAY_FREE(volty_array);
/* Generated */          ARRAY_FREE(v_sum_array);
/* Generated */          VALUE_HANDLE_DEREF_TO_ZERO(outBegIdx);
/* Generated */          VALUE_HANDLE_DEREF_TO_ZERO(outNBElement);
/* Generated */          return ENUM_VALUE(RetCode,TA_ALLOC_ERR,AllocErr);
/* Generated */       }
/* Generated */    #endif
/* Generated */    beta = 0.45 * (optInTimePeriod - 1.0) / (0.45 * (optInTimePeriod - 1.0) + 2.0);
/* Generated */    pFactor = std_log(std_sqrt((double)optInTimePeriod)) / std_log(2.0) + 2.0;
/* Generated */    if( pFactor < 0.0 )
/* Generated */       pFactor = 0.0;
/* Generated */    pRelVol = pFactor - 2.0;
/* Generated */    if( pRelVol < 0.5 )
/* Generated */       pRelVol = 0.5;
/* Generated */    if( optInPhase > 100 )
/* Generated */       PR = 2.5;
/* Generated */    else
/* Generated */       PR = optInPhase / 100.0 + 1.5;
/* Generated */    MA1 = inReal[startIdx - lookbackTotal];
/* Generated */    Det0 = 0.0;
/* Generated */    MA2 = inReal[startIdx - lookbackTotal];
/* Generated */    Det1 = 0.0;
/* Generated */    upper_band = inReal[startIdx - lookbackTotal];
/* Generated */    lower_band = inReal[startIdx - lookbackTotal];
/* Generated */    dPow_prev = pRelVol;
/* Generated */    avg_volty_sum = 0.0;
/* Generated */    v_sum_window_start = 0;
/* Generated */    today = startIdx - lookbackTotal;
/* Generated */    outIdx = 0;
/* Generated */    while( today <= endIdx )
/* Generated */    {
/* Generated */       Kv = pow(beta, std_sqrt(dPow_prev));
/* Generated */       del1 = inReal[today] - upper_band;
/* Generated */       del2 = inReal[today] - lower_band;
/* Generated */       if( del1 > 0.0 )
/* Generated */          upper_band = inReal[today];
/* Generated */       else
/* Generated */          upper_band = inReal[today] - Kv * del1;
/* Generated */       if( del2 < 0.0 )
/* Generated */          lower_band = inReal[today];
/* Generated */       else
/* Generated */          lower_band = inReal[today] - Kv * del2;
/* Generated */       abs_del1 = std_fabs(del1);
/* Generated */       abs_del2 = std_fabs(del2);
/* Generated */       if( abs_del1 == abs_del2 )
/* Generated */          volty = 0.0;
/* Generated */       else
/* Generated */          volty = (abs_del1 > abs_del2) ? abs_del1 : abs_del2;
/* Generated */       if( today >= startIdx - lookbackTotal + 10 )
/* Generated */       {
/* Generated */          v_sum_array[today - (startIdx - lookbackTotal)] = 
/* Generated */             v_sum_array[today - (startIdx - lookbackTotal) - 1] + 
/* Generated */             (volty - volty_array[today - (startIdx - lookbackTotal) - 10]) / 10.0;
/* Generated */       }
/* Generated */       else if( today > startIdx - lookbackTotal )
/* Generated */       {
/* Generated */          v_sum_array[today - (startIdx - lookbackTotal)] = 
/* Generated */             v_sum_array[today - (startIdx - lookbackTotal) - 1];
/* Generated */       }
/* Generated */       else
/* Generated */       {
/* Generated */          v_sum_array[0] = volty;
/* Generated */       }
/* Generated */       volty_array[today - (startIdx - lookbackTotal)] = volty;
/* Generated */       if( today >= startIdx - lookbackTotal + optInVolPeriods - 1 )
/* Generated */       {
/* Generated */          int array_idx = today - (startIdx - lookbackTotal);
/* Generated */          if( today == startIdx - lookbackTotal + optInVolPeriods - 1 )
/* Generated */          {
/* Generated */             avg_volty_sum = 0.0;
/* Generated */             for( i = array_idx - optInVolPeriods + 1; i <= array_idx; i++ )
/* Generated */                avg_volty_sum += v_sum_array[i];
/* Generated */             v_sum_window_start = array_idx - optInVolPeriods + 1;
/* Generated */          }
/* Generated */          else
/* Generated */          {
/* Generated */             avg_volty_sum = avg_volty_sum - v_sum_array[v_sum_window_start] + v_sum_array[array_idx];
/* Generated */             v_sum_window_start++;
/* Generated */          }
/* Generated */          avg_volty_array[array_idx] = avg_volty_sum / optInVolPeriods;
/* Generated */       }
/* Generated */       else if( today > startIdx - lookbackTotal )
/* Generated */       {
/* Generated */          int array_idx = today - (startIdx - lookbackTotal);
/* Generated */          double sum = 0.0;
/* Generated */          for( i = 0; i <= array_idx; i++ )
/* Generated */             sum += v_sum_array[i];
/* Generated */          avg_volty_array[array_idx] = sum / (array_idx + 1);
/* Generated */       }
/* Generated */       else
/* Generated */       {
/* Generated */          avg_volty_array[0] = (v_sum_array[0] > 0.0) ? v_sum_array[0] : 1.0;
/* Generated */       }
/* Generated */       {
/* Generated */          int array_idx = today - (startIdx - lookbackTotal);
/* Generated */          if( avg_volty_array[array_idx] > 0.0 )
/* Generated */             r_volty = volty / avg_volty_array[array_idx];
/* Generated */          else
/* Generated */             r_volty = 1.0;
/* Generated */          if( r_volty < 1.0 )
/* Generated */             r_volty = 1.0;
/* Generated */          if( pRelVol > 0.0 )
/* Generated */          {
/* Generated */             max_r_volty = pow(pFactor, 1.0 / pRelVol);
/* Generated */             if( r_volty > max_r_volty )
/* Generated */                r_volty = max_r_volty;
/* Generated */          }
/* Generated */       }
/* Generated */       dPow = pow(r_volty, pRelVol);
/* Generated */       alpha = pow(beta, dPow);
/* Generated */       MA1 = (1.0 - alpha) * inReal[today] + alpha * MA1;
/* Generated */       Det0 = (inReal[today] - MA1) * (1.0 - beta) + beta * Det0;
/* Generated */       MA2 = MA1 + PR * Det0;
/* Generated */       if( today > startIdx - lookbackTotal )
/* Generated */       {
/* Generated */          double one_minus_alpha_sq = (1.0 - alpha) * (1.0 - alpha);
/* Generated */          double alpha_sq = alpha * alpha;
/* Generated */          Det1 = (MA2 - outRealJMA[outIdx - 1]) * one_minus_alpha_sq + alpha_sq * Det1;
/* Generated */          outRealJMA[outIdx] = outRealJMA[outIdx - 1] + Det1;
/* Generated */       }
/* Generated */       else
/* Generated */       {
/* Generated */          outRealJMA[outIdx] = MA2;
/* Generated */       }
/* Generated */       dPow_prev = dPow;
/* Generated */       if( today >= startIdx )
/* Generated */       {
/* Generated */          outRealUpperBand[outIdx] = upper_band;
/* Generated */          outRealLowerBand[outIdx] = lower_band;
/* Generated */          outIdx++;
/* Generated */       }
/* Generated */       today++;
/* Generated */    }
/* Generated */    ARRAY_FREE(volty_array);
/* Generated */    ARRAY_FREE(v_sum_array);
/* Generated */    ARRAY_FREE(avg_volty_array);
/* Generated */    VALUE_HANDLE_DEREF(outBegIdx) = startIdx;
/* Generated */    VALUE_HANDLE_DEREF(outNBElement) = outIdx;
/* Generated */    return ENUM_VALUE(RetCode,TA_SUCCESS,Success);
/* Generated */ }
/* Generated */ 
/* Generated */ #if defined( _MANAGED )
/* Generated */ }}} // Close namespace TicTacTec.TA.Lib
/* Generated */ #elif defined( _RUST )
/* Generated */ } // Close impl Core
/* Generated */ #endif
/**** END GENCODE SECTION 5 - DO NOT DELETE THIS LINE ****/

